#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Network Exploit Manager
- Modular design dengan exploits terpisah
- Real code execution
- Clean output
"""

import os
import sys
import importlib.util
from pathlib import Path
from typing import List, Optional
from dataclasses import dataclass

from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.prompt import Prompt, Confirm
from rich import box

console = Console()

MODULE_INFO = {
    "name": "Network Exploit Manager",
    "description": "Port-based network services exploitation with real code execution",
    "author": "Lazy Framework Team",
    "license": "MIT",
    "platform": "Multi",
    "rank": "Excellent",
    "dependencies": ["rich"]
}

OPTIONS = {
    "TARGET": {
        "description": "Target IP address",
        "required": True,
        "default": "192.168.1.100"
    },
    "PORTS": {
        "description": "Specific ports to scan (comma separated)",
        "required": False,
        "default": ""
    }
}

@dataclass
class ServiceExploit:
    id: str
    name: str
    port: int
    protocol: str
    service: str
    risk: str
    description: str
    author: str
    module: str  # Nama file module tanpa .py
    verified: bool = False

class NetworkExploitManager:
    def __init__(self, options):
        self.options = options or {}
        self.target = self.options.get("TARGET", OPTIONS["TARGET"]["default"])
        self.ports = self.options.get("PORTS", OPTIONS["PORTS"]["default"])
        self.exploits: List[ServiceExploit] = []
        self.exploits_dir = Path("/data/data/com.termux/files/home/S/modules/webshell/exploit")
    
        if not self.exploits_dir.exists():
            console.print(f"ERROR: Exploits directory not found: {self.exploits_dir}")
        # Fallback ke directory module
            self.exploits_dir = Path(__file__).parent
            console.print(f"Using fallback directory: {self.exploits_dir}")
        console.print(f"Exploits directory: {self.exploits_dir}")
        self.load_exploits()
    def load_exploits(self):
        """Load exploits dari file terpisah"""
        exploits_data = [
            {
                "id": "ftp-anon",
                "name": "FTP Anonymous Login",
                "port": 21,
                "protocol": "tcp", 
                "service": "ftp",
                "risk": "medium",
                "description": "Exploit FTP servers with anonymous authentication",
                "author": "Lazy Framework Team",
                "module": "ftp_anonymous",
                "verified": True
            },
            {
                "id": "ftp-enum",
                "name": "FTP Enumeration",
                "port": 21,
                "protocol": "tcp",
                "service": "ftp",
                "risk": "medium",
                "description": "Full FTP enumeration with banner, anonymous, users, and features",
                "author": "Lazy Framework Team",
                "module": "ftp_enum",
                "verified": True
            },
            {
                "id": "ssh-brute", 
                "name": "SSH Brute Force",
                "port": 22,
                "protocol": "tcp",
                "service": "ssh",
                "risk": "medium",
                "description": "SSH credential brute force attack",
                "author": "Lazy Framework Team",
                "module": "ssh_bruteforce",
                "verified": True
            },
            {
                "id": "smb-anon",
                "name": "SMB Anonymous Share",
                "port": 445,
                "protocol": "tcp",
                "service": "smb",
                "risk": "medium",
                "description": "Access SMB shares with anonymous credentials",
                "author": "Lazy Framework Team", 
                "module": "smb_anonymous",
                "verified": True
            },

            {
                "id": "snmp-enum",
                "name": "SNMP Enumeration",
                "port": 161,
                "protocol": "udp",
                "service": "snmp",
                "risk": "medium",
                "description": "Enumerate SNMP services",
                "author": "Lazy Framework Team",
                "module": "snmp_enum",
                "verified": True
             },

            {
                "id": "mysql-unauth",
                "name": "MySQL Unauthorized Access",
                "port": 3306,
                "protocol": "tcp",
                "service": "mysql",
                "risk": "high",
                "description": "MySQL database unauthorized access",
                "author": "Lazy Framework Team",
                "module": "mysql_unauth",
                "verified": True
            },
            {
                "id": "redis-unauth",
                "name": "Redis Unauthorized Access", 
                "port": 6379,
                "protocol": "tcp",
                "service": "redis",
                "risk": "high",
                "description": "Redis unauthorized access exploitation",
                "author": "Lazy Framework Team",
                "module": "redis_unauth",
                "verified": True
            }
        ]
        
        for data in exploits_data:
            self.exploits.append(ServiceExploit(**data))
        
        console.print(f"Loaded {len(self.exploits)} exploit modules")

    def show_dashboard(self):
        """Tampilan dashboard"""
        console.clear()
        console.print(Panel(
            f"Network Exploit Manager\nTarget: {self.target} | Exploits: {len(self.exploits)}",
            title="EXPLOIT MANAGER"
        ))
        console.print()

    def list_exploits(self, service_filter=None):
        """List semua exploits"""
        if service_filter:
            filtered = [e for e in self.exploits if e.service.lower() == service_filter.lower()]
            title = f"EXPLOITS FOR {service_filter.upper()}"
        else:
            filtered = self.exploits
            title = "AVAILABLE EXPLOITS"

        if not filtered:
            console.print("No exploits found")
            return

        table = Table(box=box.SIMPLE, show_header=True)
        table.add_column("ID", style="red", width=30, overflow="fold")
        table.add_column("Service", width=30)
        table.add_column("Name", width=30, overflow="fold")
        table.add_column("Risk", width=15)
        table.add_column("Port", width=30)
        table.add_column("Description")

        for exp in filtered:
            table.add_row(
                exp.id,
                exp.service.upper(),
                exp.name,
                exp.risk.upper(),
                str(exp.port),
                exp.description
            )

        console.print(Panel(table, title=title))

    def show_exploit_details(self, exploit_id):
        """Show detail exploit"""
        exploit = next((e for e in self.exploits if e.id == exploit_id), None)
        if not exploit:
            console.print(f"Exploit {exploit_id} not found")
            return

        info = f"""Name: {exploit.name}
ID: {exploit.id}
Service: {exploit.service.upper()}
Port: {exploit.port}/{exploit.protocol}
Risk: {exploit.risk.upper()}
Author: {exploit.author}
Verified: {'Yes' if exploit.verified else 'No'}
Module: {exploit.module}.py

Description:
{exploit.description}"""

        console.print(Panel(info, title="EXPLOIT DETAILS"))

    def run_exploit(self, exploit_id):
        """Run exploit dengan module terpisah"""
        exploit = next((e for e in self.exploits if e.id == exploit_id), None)
        if not exploit:
            console.print(f"Exploit {exploit_id} not found")
            return
        console.print(Panel(
            f"Running: {exploit.name}\nTarget: {self.target}:{exploit.port}",
            title="EXECUTING EXPLOIT"
        ))
        if not Confirm.ask("Continue?"):
            console.print("Cancelled")
            return
        # Load dan execute module
        module_path = self.exploits_dir / f"{exploit.module}.py"
        # Debug: Tampilkan path yang dicari
        #console.print(f"Looking for module: {module_path}")
        #console.print(f"Directory exists: {self.exploits_dir.exists()}")
        if self.exploits_dir.exists():
           files = list(self.exploits_dir.glob("*.py"))
           #console.print(f"Python files in directory: {[f.name for f in files]}")
        if not module_path.exists():
           #console.print(f"Module {exploit.module}.py not found at: {module_path}")
           return
        try:
        # Import module dynamically
            spec = importlib.util.spec_from_file_location(exploit.module, module_path)
            module = importlib.util.module_from_spec(spec)
        # Execute the module
            spec.loader.exec_module(module)
            # Call the main function if it exists
            if hasattr(module, 'run_exploit'):
                result = module.run_exploit(self.target)
                console.print(Panel(
                result, 
                title="Exploit Output", 
                style="green" if "Error" not in result else "red"
            ))
            else:
                console.print("No run_exploit function found in module")
        except Exception as e:
            console.print(f"[red]Error: {e}[/]")

    def show_services(self):
        """Show available services"""
        services = {}
        for exp in self.exploits:
            services[exp.service] = services.get(exp.service, 0) + 1
        items = [f"{svc.upper()} ({count})" for svc, count in services.items()]
        try:
            terminal_width = shutil.get_terminal_size().columns
        except:
            terminal_width = 80
        max_item_width = max(len(item) for item in items) if items else 10
        max_item_width = max(max_item_width, 12)  # minimal 12
        padding = 4  # spasi antar item
        items_per_line = max(1, (terminal_width - 10) // (max_item_width + padding))
        columns = [items[i:i + items_per_line] for i in range(0, len(items), items_per_line)]
        lines = []
        max_col_count = max(len(col) for col in columns)  # Max jumlah item di kolom
        def get_color(service):
        """Menentukan warna berdasarkan service"""
            color_map = {
                'ftp': 'red',    # FTP: Merah
                'ssh': 'yellow', # SSH: Kuning
                'mysql': 'green', # MySQL: Hijau
                'smb': 'yellow', # SMB: Kuning
                'snmp': 'green', # SNMP: Hijau
                'redis': 'red'   # Redis: Merah
            }
            return color_map.get(service.lower(), 'white')  # Default ke putih jika tidak ada warna khusus
         for i in range(max_col_count):
             line = "  ".join(
                (f"[{get_color(columns[j][i].split()[0])}]{columns[j][i]}[/]" if i < len(columns[j]) else "").ljust(max_item_width)
                for j in range(len(columns))
             )
             lines.append(line.center(terminal_width - 4))  # Menambahkan spasi di kiri dan kanan agar terpusat

         text = "\n".join(lines) if lines else "No services"
         console.print(Panel(
                 text,
                 title="AVAILABLE SERVICES",
                 title_align="center",
                 border_style="white",
                 padding=(1, 2),
                 expand=False
         ))

    def show_help(self):
        """Show help"""
        help_text = """
Commands:
  services               - Show available services
  list [service]         - List exploits (optionally by service)
  show [id]              - Show exploit details  
  run [id]               - Run exploit
  target [ip]            - Set target
  clear                  - Clear screen
  help                   - Show this help
  exit                   - Exit

Examples:
  list ftp               - List FTP exploits
  show ftp-anon          - Show FTP anonymous exploit details
  run ftp-anon           - Run FTP anonymous exploit
  target 10.0.0.5        - Set target to 10.0.0.5
"""
        console.print(Panel(help_text, title="HELP"))

    def interactive_shell(self):
        """Main interactive shell"""
        console.print("Type 'help' for commands\n")
        
        while True:
            try:
                cmd = Prompt.ask(f"exploits[{self.target}]").strip()
                if not cmd:
                    continue
                    
                parts = cmd.split()
                action = parts[0].lower()
                args = parts[1:]
                
                if action in ['exit', 'quit']:
                    break
                elif action == 'help':
                    self.show_help()
                elif action == 'services':
                    self.show_services()
                elif action == 'list':
                    self.list_exploits(args[0] if args else None)
                elif action == 'show':
                    if args:
                        self.show_exploit_details(args[0])
                    else:
                        console.print("Usage: show [exploit_id]")
                elif action == 'run':
                    if args:
                        self.run_exploit(args[0])
                    else:
                        console.print("Usage: run [exploit_id]")
                elif action == 'target':
                    if args:
                        self.target = args[0]
                        console.print(f"Target set to: {self.target}")
                    else:
                        console.print(f"Current target: {self.target}")
                elif action == 'clear':
                    console.clear()
                    self.show_dashboard()
                else:
                    console.print("Unknown command. Type 'help' for commands.")
                    
                console.print()
                
            except KeyboardInterrupt:
                console.print("\nUse 'exit' to quit")
            except Exception as e:
                console.print(f"Error: {e}")

    def run(self):
        """Main run method"""
        self.show_dashboard()
        self.show_services()
        self.interactive_shell()

def run(session=None, options=None):
    manager = NetworkExploitManager(options or {})
    manager.run()

if __name__ == "__main__":
    run()
